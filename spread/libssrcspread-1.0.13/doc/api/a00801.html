<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for FreeBSD version 5.4.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Ssrc C++/Lua/Perl/Python/Ruby Bindings for Spread API 1.0.13: Lua/Perl/Python/Ruby API Differences</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#FFFFFF">
<div style="text-align: left; clear: both;"><a href="http://www.savarese.com/"><img src="logoSmall.jpg" alt="Savarese Software Research Corporation" width="144" height="36" border="0" align="top" hspace="0" vspace="0"></a><br clear="all"></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script> 
<script type="text/javascript" src="menu.js"></script> 
<script type="text/javascript">

$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
<ul>
<li class="navelem"><a class="el" href="index.html">index</a></li>
</ul>
</div>
<!-- top -->
<div class="header">
<div class="headertitle">
<div class="title">Lua/Perl/Python/Ruby API Differences</div>
</div>
</div>
<!--header-->
<div class="contents">
<div class="textblock">
<p>The Lua, Perl, Python, and Ruby bindings use the same naming scheme as the C++ API in almost every case.</p>
<p>No attempt has been made to customize the API to the idioms of the respective scripting languages. This allows you to use the C++ API documentation for all environments. However, a few differences are forced upon the API by the languages. See the unit tests in <code>tests/swig/lua</code>, <code>tests/swig/perl</code>, <code>tests/swig/python</code>, and <code>tests/swig/ruby</code> for usage examples.</p>
<h1><a class="anchor" id="lua_diff"></a> Lua Differences</h1>
<ul>
<li><code>#include &lt;<a class="el" href="a00056.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread namespace...">ssrc/spread.h</a>&gt;</code> becomes <code>require("ssrc.spread")</code></li>
<li>ssrc::spread::foo becomes ssrc.spread.foo</li>
<li>Static constants and enums that are class members cannot be accessed via the dot operator. Instead they are mapped to the class name followed by an underscore followed by the constant name. For example, <code>ssrc::spread::BaseMessage::SelfDiscard</code> becomes <code>ssrc.spread.BaseMessage_SelfDiscard</code>.</li>
<li>When you reference class constants, you must reference the class in which they are defined. For example, use <code>ssrc.spread.BaseMessage_SelfDiscard</code> instead of <code>ssrc.spread.Message_SelfDiscard</code></li>
<li>There are no bitwise logical operators in Lua. Therefore, you cannot use bitmasks. Instead of <code>ssrc::spread::BaseMessage::Reliable | ssrc::spread::BaseMessage::SelfDiscard</code> use <code>ssrc.spread.BaseMessage_ReliableSelfDiscard</code>.</li>
<li><a class="el" href="a00615.html" title="Error is a container for a Spread error code and is thrown by the library in only truly exceptional c...">Error</a> and <a class="el" href="a00619.html" title="BufferSizeError is a container for a BufferTooShort or GroupTooShort errror, reporting the buffer siz...">BufferSizeError</a> cannot be caught in Lua, but you can prevent your program from exiting by using <code>pcall</code>. For example, the Lua unit tests do the following:
<pre class="fragment">  function test_error()
    local succeeded, message = pcall(mbox.join, mbox, "####");
    assert(not succeeded)
  end
</pre></li>
</ul>
<h1><a class="anchor" id="perl_diff"></a> Perl Differences</h1>
<ul>
<li><code>#include &lt;<a class="el" href="a00056.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread namespace...">ssrc/spread.h</a>&gt;</code> becomes <code>use ssrc::spread;</code></li>
<li>ssrc::spread::foo becomes ssrc::spread::foo</li>
<li><a class="el" href="a00035.html#ad02b6d7845702ad0418d2ab8cf1a9163" title="Splits a private group name into its private name and process name components. ">split_private_group()</a> is not implemented</li>
<li>When you reference class constants, you must reference the class in which they are defined. For example, use <code>$ssrc::spread::BaseMessage::SelfDiscard</code> instead of <code>$ssrc::spread::Message::SelfDiscard</code></li>
<li><a class="el" href="a00615.html" title="Error is a container for a Spread error code and is thrown by the library in only truly exceptional c...">Error</a> and <a class="el" href="a00619.html" title="BufferSizeError is a container for a BufferTooShort or GroupTooShort errror, reporting the buffer siz...">BufferSizeError</a> can be caught in Perl only via the use of <code>eval</code>, which makes the exception available via the <code>$@</code> special variable. For example, the Perl unit tests do the following:
<pre class="fragment">  sub test_error {
    eval { $mbox-&gt;join("####"); };
    is($@-&gt;error(), $ssrc::spread::Error::IllegalGroup);
  }
</pre></li>
</ul>
<h1><a class="anchor" id="py_diff"></a> Python Differences</h1>
<ul>
<li><code>#include &lt;<a class="el" href="a00056.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread namespace...">ssrc/spread.h</a>&gt;</code> becomes <code>import ssrc.spread</code></li>
<li>ssrc::spread::foo becomes ssrc.spread.foo</li>
<li><a class="el" href="a00615.html#a00d19532a87610d34831bdc24d59245b" title="Prints the message corresponding to the error via SP_error. ">Error::print()</a> becomes Error._print()</li>
</ul>
<h1><a class="anchor" id="rb_diff"></a> Ruby Differences</h1>
<ul>
<li><code>#include &lt;<a class="el" href="a00056.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread namespace...">ssrc/spread.h</a>&gt;</code> becomes <code>require 'ssrc/spread'</code></li>
<li>ssrc::spread::foo becomes Ssrc::Spread::foo</li>
</ul>
<h1><a class="anchor" id="shared_diff"></a> Shared Differences</h1>
<ul>
<li>The Spread C API is not available in the Spread namespace.</li>
<li><a class="el" href="a00035.html#ad02b6d7845702ad0418d2ab8cf1a9163" title="Splits a private group name into its private name and process name components. ">split_private_group()</a> (not implemented in Perl) expects only the private group name as a parameter and returns an array (Ruby) or tuple (Python). For example:
<pre class="fragment">  private_name, proc_name = ssrc.spread.split_private_group("#foo#bar")
  private_name == "foo" # This expression evaluates to True
  proc_name == "bar" # This expression evaluates to True
</pre>
In Lua <a class="el" href="a00035.html#ad02b6d7845702ad0418d2ab8cf1a9163" title="Splits a private group name into its private name and process name components. ">split_private_group()</a> returns a C++-style pair with .first and .second members, just like the C++ API.<br>
You don't really need <a class="el" href="a00035.html#ad02b6d7845702ad0418d2ab8cf1a9163" title="Splits a private group name into its private name and process name components. ">split_private_group()</a> in the scripting environment because the same result can be obtained via string manipulation functions or regular expressions.</li>
<li>operator=() becomes copy()<br>
For example:
<pre class="fragment">  g1 = ssrc.spread.GroupList()
  g2 = ssrc.spread.GroupList()
  g1.add("foo")
  g2.copy(g1)
  g2.group(0) == "foo" # This expression evaluates to True.
</pre></li>
<li>operator[] is unavailable. Use the corresponding accessor method instead. For example, use <a class="el" href="a00623.html#a0881d412495f731153b932bd99878f45" title="Returns the group name at the specified index. ">GroupList::group</a>.</li>
<li>Messages are treated as strings. If there is user demand, functions for creating raw memory buffers can be exported into the scripting environment. But for now, we feel it is best to serialize script objects into strings (e.g., with Python pickling) or create script bindings of your C++ data types that are sent as messages instead of trying to manipulate memory allocation in the scripting environment.</li>
<li>Message::read returns a string and Message::write expects a string parameter. Message::read expects the maximum number of bytes to read as a parameter. For example:
<pre class="fragment">  m = ssrc.spread.Message()
  m.write("foobar")
  m.rewind()
  s = m.read(m.size())
  "foobar" == s # This expression evaluates to True.
</pre></li>
<li>The C++ versions of Message::read and Message::write are available as <code>readn</code> and <code>writen</code>. Note, that <code>readn</code> is dangerous (e.g., strings are supposed to be immutable in Python) and should be avoided unless you know exactly what you're doing.</li>
<li><a class="el" href="a00643.html#a379f161c62846c96e49ef7fbcd5921d3" title="Adds a message part to the ScatterMessage with a designated number of bytes indicating either the cap...">ScatterMessage::add(const void *, unsigned int)</a> and <a class="el" href="a00635.html#afc8b55dfe2065fb263ca746a665a02f2" title="Adds a message part to the internal ScatterMessage. ">Mailbox::add_message_part(const void *, unsigned int)</a> expect only a string as a parameter (same as the Message::write mapping). You should avoid using this form of the method for receives. Instead, use <a class="el" href="a00639.html" title="Message is a reusable and resizable data buffer for sending and receiving messages. ">Message</a> parts for receives, or you may overwrite script data structures in unpredictable ways.</li>
</ul>
<h1><a class="anchor" id="considerations"></a> Additional Considerations</h1>
<p>The <a class="el" href="a00635.html" title="The Mailbox class wraps the file descriptor returned after establishing a connection to a Spread daem...">Mailbox</a> class uses the C++ idiom of resource acquisition is initialization. Therefore, no disconnect method is exposed and the disconnect happens in the destructor. In a garbage-collected scripting language, this means the disconnect may not happen at a predictable point when you stop using the object. You can invoke Mailbox::kill to free the file descriptor immediately, but don't continue to use the object afterward.</p>
<p>In order to specify a connection timeout, you may use the <a class="el" href="a00631.html" title="Timeout is a simple wrapper around Spread::sp_time the Spread C API's Spread::sp_time struct that fac...">Timeout</a> class or you may specify a timeout in seconds with a single integer. For example, to specify a connection timeout of 3 seconds in Python, you could use:</p>
<pre class="fragment">mbox = ssrc.spread.Mailbox("4803@localhost", "", True, ssrc.spread.Timeout(3));</pre>
<p>or:</p>
<pre class="fragment">mbox = ssrc.spread.Mailbox("4803@localhost", "", True, 3);</pre>
<p>You can't access the contents of a <a class="el" href="a00639.html" title="Message is a reusable and resizable data buffer for sending and receiving messages. ">Message</a> directly via <code>&<a class="el" href="a00639.html" title="Message is a reusable and resizable data buffer for sending and receiving messages. ">Message</a>[0]</code> as in C++. Instead, you always have to read and write the contents using Message::read and Message::write. Because messages are treated as strings in the script environment, your data shouldn't contain null/0 characters. For example, if you write two strings to a message in a row and read them back into one string, you'll find that the result is treated as only the first string because of the null termination. For example:</p>
<pre class="fragment">m = ssrc.spread.Message()
m.write("foo")
m.write("bar")
m.rewind()
s = m.read(m.size())
"foo" == s # This expression evaluates to True.
"foobar" == s # This expression evaluates to False.
m.rewind()
s1 = m.read(4)
s2 = m.read(4)
"foo" == s1 # This expression evaluates to True.
"bar" == s2 # This expression evaluates to True.
</pre>
<p>As long as you use the script environment's object serialization mechanisms, you shouldn't run into any problems in this regard.</p>
<p>Don't add raw data parts (things that are not of type <a class="el" href="a00639.html" title="Message is a reusable and resizable data buffer for sending and receiving messages. ">Message</a>) to <a class="el" href="a00643.html#a379f161c62846c96e49ef7fbcd5921d3" title="Adds a message part to the ScatterMessage with a designated number of bytes indicating either the cap...">ScatterMessage::add</a> or <a class="el" href="a00635.html#afc8b55dfe2065fb263ca746a665a02f2" title="Adds a message part to the internal ScatterMessage. ">Mailbox::add_message_part</a> if they will be garbage-collected before a send. For example:</p>
<pre class="fragment">s = "foo"
mbox.add_message_part(s)
s = None # Don't do this before the send or you may segfault!
mbox.send()
</pre></div>
</div>
<!-- contents -->
<hr>
<div style="float: left;"><a href="http://www.savarese.com/"><img src="logoSmall.jpg" alt="Savarese Software Research Corporation" width="144" height="36" border="0" align="top" hspace="0" vspace="0"></a></div>
<div style="text-align:right">Copyright © 2006-2015 Savarese Software Research Corporation. All rights reserved.</div>
</body>
</html>
