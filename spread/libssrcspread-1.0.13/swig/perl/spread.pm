# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package ssrc::spread;
use base qw(Exporter);
use base qw(DynaLoader);
package ssrc::spreadc;
bootstrap ssrc::spread;
package ssrc::spread;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package ssrc::spread;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package ssrc::spread;

*split_private_group = *ssrc::spreadc::split_private_group;
*__eq__ = *ssrc::spreadc::__eq__;

############# Class : ssrc::spread::Error ##############

package ssrc::spread::Error;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread );
%OWNER = ();
%ITERATORS = ();
*AcceptSession = *ssrc::spreadc::Error_AcceptSession;
*IllegalSpread = *ssrc::spreadc::Error_IllegalSpread;
*CouldNotConnect = *ssrc::spreadc::Error_CouldNotConnect;
*RejectQuota = *ssrc::spreadc::Error_RejectQuota;
*RejectNoName = *ssrc::spreadc::Error_RejectNoName;
*RejectIllegalName = *ssrc::spreadc::Error_RejectIllegalName;
*RejectNotUnique = *ssrc::spreadc::Error_RejectNotUnique;
*RejectVersion = *ssrc::spreadc::Error_RejectVersion;
*ConnectionClosed = *ssrc::spreadc::Error_ConnectionClosed;
*RejectAuth = *ssrc::spreadc::Error_RejectAuth;
*IllegalSession = *ssrc::spreadc::Error_IllegalSession;
*IllegalService = *ssrc::spreadc::Error_IllegalService;
*IllegalMessage = *ssrc::spreadc::Error_IllegalMessage;
*IllegalGroup = *ssrc::spreadc::Error_IllegalGroup;
*BufferTooShort = *ssrc::spreadc::Error_BufferTooShort;
*GroupsTooShort = *ssrc::spreadc::Error_GroupsTooShort;
*MessageTooLong = *ssrc::spreadc::Error_MessageTooLong;
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_Error(@_);
    bless $self, $pkg if defined($self);
}

*error = *ssrc::spreadc::Error_error;
*print = *ssrc::spreadc::Error_print;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_Error($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::BufferSizeError ##############

package ssrc::spread::BufferSizeError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread::Error ssrc::spread );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_BufferSizeError(@_);
    bless $self, $pkg if defined($self);
}

*size = *ssrc::spreadc::BufferSizeError_size;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_BufferSizeError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::GroupList ##############

package ssrc::spread::GroupList;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_GroupList(@_);
    bless $self, $pkg if defined($self);
}

*add = *ssrc::spreadc::GroupList_add;
*group = *ssrc::spreadc::GroupList_group;
*copy = *ssrc::spreadc::GroupList_copy;
*clear = *ssrc::spreadc::GroupList_clear;
*size = *ssrc::spreadc::GroupList_size;
*__eq__ = *ssrc::spreadc::GroupList___eq__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_GroupList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::BaseMessage ##############

package ssrc::spread::BaseMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread );
%OWNER = ();
%ITERATORS = ();
*Unreliable = *ssrc::spreadc::BaseMessage_Unreliable;
*Reliable = *ssrc::spreadc::BaseMessage_Reliable;
*FIFO = *ssrc::spreadc::BaseMessage_FIFO;
*Causal = *ssrc::spreadc::BaseMessage_Causal;
*Agreed = *ssrc::spreadc::BaseMessage_Agreed;
*Safe = *ssrc::spreadc::BaseMessage_Safe;
*SelfDiscard = *ssrc::spreadc::BaseMessage_SelfDiscard;
*DropReceive = *ssrc::spreadc::BaseMessage_DropReceive;
*UnreliableSelfDiscard = *ssrc::spreadc::BaseMessage_UnreliableSelfDiscard;
*ReliableSelfDiscard = *ssrc::spreadc::BaseMessage_ReliableSelfDiscard;
*FIFOSelfDiscard = *ssrc::spreadc::BaseMessage_FIFOSelfDiscard;
*CausalSelfDiscard = *ssrc::spreadc::BaseMessage_CausalSelfDiscard;
*AgreedSelfDiscard = *ssrc::spreadc::BaseMessage_AgreedSelfDiscard;
*SafeSelfDiscard = *ssrc::spreadc::BaseMessage_SafeSelfDiscard;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_BaseMessage($self);
        delete $OWNER{$self};
    }
}

*size = *ssrc::spreadc::BaseMessage_size;
*clear = *ssrc::spreadc::BaseMessage_clear;
*set_service = *ssrc::spreadc::BaseMessage_set_service;
*service = *ssrc::spreadc::BaseMessage_service;
*set_type = *ssrc::spreadc::BaseMessage_set_type;
*type = *ssrc::spreadc::BaseMessage_type;
*set_sender = *ssrc::spreadc::BaseMessage_set_sender;
*sender = *ssrc::spreadc::BaseMessage_sender;
*set_endian_mismatch = *ssrc::spreadc::BaseMessage_set_endian_mismatch;
*endian_mismatch = *ssrc::spreadc::BaseMessage_endian_mismatch;
*set_agreed = *ssrc::spreadc::BaseMessage_set_agreed;
*is_agreed = *ssrc::spreadc::BaseMessage_is_agreed;
*set_causal = *ssrc::spreadc::BaseMessage_set_causal;
*is_causal = *ssrc::spreadc::BaseMessage_is_causal;
*set_fifo = *ssrc::spreadc::BaseMessage_set_fifo;
*is_fifo = *ssrc::spreadc::BaseMessage_is_fifo;
*set_reliable = *ssrc::spreadc::BaseMessage_set_reliable;
*is_reliable = *ssrc::spreadc::BaseMessage_is_reliable;
*set_unreliable = *ssrc::spreadc::BaseMessage_set_unreliable;
*is_unreliable = *ssrc::spreadc::BaseMessage_is_unreliable;
*set_safe = *ssrc::spreadc::BaseMessage_set_safe;
*is_safe = *ssrc::spreadc::BaseMessage_is_safe;
*set_self_discard = *ssrc::spreadc::BaseMessage_set_self_discard;
*is_self_discard = *ssrc::spreadc::BaseMessage_is_self_discard;
*is_regular = *ssrc::spreadc::BaseMessage_is_regular;
*is_membership = *ssrc::spreadc::BaseMessage_is_membership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::Message ##############

package ssrc::spread::Message;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread::BaseMessage ssrc::spread );
%OWNER = ();
%ITERATORS = ();
*DefaultCapacity = *ssrc::spreadc::Message_DefaultCapacity;
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_Message(@_);
    bless $self, $pkg if defined($self);
}

*size = *ssrc::spreadc::Message_size;
*clear = *ssrc::spreadc::Message_clear;
*capacity = *ssrc::spreadc::Message_capacity;
*resize = *ssrc::spreadc::Message_resize;
*offset = *ssrc::spreadc::Message_offset;
*rewind = *ssrc::spreadc::Message_rewind;
*seek = *ssrc::spreadc::Message_seek;
*readn = *ssrc::spreadc::Message_readn;
*writen = *ssrc::spreadc::Message_writen;
*write = *ssrc::spreadc::Message_write;
*read = *ssrc::spreadc::Message_read;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_Message($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::ScatterMessage ##############

package ssrc::spread::ScatterMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread::BaseMessage ssrc::spread );
%OWNER = ();
%ITERATORS = ();
*MaxScatterElements = *ssrc::spreadc::ScatterMessage_MaxScatterElements;
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_ScatterMessage(@_);
    bless $self, $pkg if defined($self);
}

*size = *ssrc::spreadc::ScatterMessage_size;
*clear = *ssrc::spreadc::ScatterMessage_clear;
*count_message_parts = *ssrc::spreadc::ScatterMessage_count_message_parts;
*count_message_objects = *ssrc::spreadc::ScatterMessage_count_message_objects;
*add = *ssrc::spreadc::ScatterMessage_add;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_ScatterMessage($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::Timeout ##############

package ssrc::spread::Timeout;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_Timeout(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_Timeout($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ssrc::spread::Mailbox ##############

package ssrc::spread::Mailbox;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ssrc::spread );
%OWNER = ();
%ITERATORS = ();
*ZeroTimeout = *ssrc::spreadc::Mailbox_ZeroTimeout;
*Low = *ssrc::spreadc::Mailbox_Low;
*Medium = *ssrc::spreadc::Mailbox_Medium;
*High = *ssrc::spreadc::Mailbox_High;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ssrc::spreadc::delete_Mailbox($self);
        delete $OWNER{$self};
    }
}

*connection = *ssrc::spreadc::Mailbox_connection;
*name = *ssrc::spreadc::Mailbox_name;
*descriptor = *ssrc::spreadc::Mailbox_descriptor;
*private_group = *ssrc::spreadc::Mailbox_private_group;
*group_membership = *ssrc::spreadc::Mailbox_group_membership;
*set_drop_receive = *ssrc::spreadc::Mailbox_set_drop_receive;
*drop_receive = *ssrc::spreadc::Mailbox_drop_receive;
*join = *ssrc::spreadc::Mailbox_join;
*leave = *ssrc::spreadc::Mailbox_leave;
*killed = *ssrc::spreadc::Mailbox_killed;
*poll = *ssrc::spreadc::Mailbox_poll;
*add_group = *ssrc::spreadc::Mailbox_add_group;
*add_groups = *ssrc::spreadc::Mailbox_add_groups;
*group = *ssrc::spreadc::Mailbox_group;
*copy_groups = *ssrc::spreadc::Mailbox_copy_groups;
*count_groups = *ssrc::spreadc::Mailbox_count_groups;
*clear_groups = *ssrc::spreadc::Mailbox_clear_groups;
*count_message_parts = *ssrc::spreadc::Mailbox_count_message_parts;
*clear_message_parts = *ssrc::spreadc::Mailbox_clear_message_parts;
*send = *ssrc::spreadc::Mailbox_send;
*receive = *ssrc::spreadc::Mailbox_receive;
*add_message_part = *ssrc::spreadc::Mailbox_add_message_part;
sub new {
    my $pkg = shift;
    my $self = ssrc::spreadc::new_Mailbox(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package ssrc::spread;

*MaxSizePrivateName = *ssrc::spreadc::MaxSizePrivateName;
*MaxSizeProcessName = *ssrc::spreadc::MaxSizeProcessName;
*MaxSizeGroupName = *ssrc::spreadc::MaxSizeGroupName;
*MinValidGroupNameChar = *ssrc::spreadc::MinValidGroupNameChar;
*MaxValidGroupNameChar = *ssrc::spreadc::MaxValidGroupNameChar;
*GroupNameSeparatorChar = *ssrc::spreadc::GroupNameSeparatorChar;

my %__Mailbox_ZeroTimeout_hash;
tie %__Mailbox_ZeroTimeout_hash,"ssrc::spread::Timeout", $ssrc::spreadc::Mailbox_ZeroTimeout;
$Mailbox_ZeroTimeout= \%__Mailbox_ZeroTimeout_hash;
bless $Mailbox_ZeroTimeout, ssrc::spread::Timeout;
1;
